// This file partially due to Kevin McGown, with modifications by Michael Rubinstein

#ifndef Lexplicit_formula_H
#define Lexplicit_formula_H


/***************************************************************************************************/

// the phi in the explicit formula
inline Complex xxx_phi(Double alpha, Double x_0, Complex x)
{
  return exp(-alpha*(x-x_0)*(x-x_0));
}

//its fourier transform
inline Complex xxx_phi_hat(Double alpha, Double x_0, Complex x)
{
  return sqrt(Pi/alpha) * exp(-2*Pi*I*x_0*x - Pi*Pi*x*x/alpha);
}

/***************************************************************************************************

With the above choice of phi, and the choice of alpha used in Lfind_zeros.h

Prime power side (i.e. RHS):
---------------------------

In phi_hat we call it with x=log(n)/(2 Pi). To get 10^(-DIGITS), roughly exp(-2.3*DIGITS),
we need Pi^2 (log(n)/(2Pi))^2 / alpha to be roughly 2.3 DIGITS. Solving for n, this requires n as big
as exp(sqrt(2.3 DIGITS 4alpha)). So alpha can't be too big, otherwise we get slaughtered on the number
of n needed. In Lfind_zeros.h I take alpha =2.3/DIGITS so that n needs to be as big as 100, very reasonable.

On the zeros side (LHS):
-----------------------

We want to see how many zeros we need to take so that alpha(x-x_0)^2 is >= 2.3 DIGITS.
If alpha = 2.3/DIGITS, this restricts |x-x_0|  < DIGITS.
In Lfind_zeros.h I take the number of zeros to be a bit more than 2*DIGITS*(density of zeros at largest height being considered).
density is Nmain(T+1)-Nmain(T), which is for an interval of length 2. That's okay because I store positive and
negative zeros in the array of zeros that is passed to the explicit formula. The extra 2 on the outside
is to account for the fact that we want zeros on either side of x_0, i.e. x-x_0 can be positive or negative, so
we need to double the number of zeros considered. Typically, though, half the zeros give an exponentially small amount,
and their contribution is not evaluated (those that are in the opposite halfplane). So the number of exp's
we need to evaluate, with the choice of alpha=2.3/DIGITS, is DIGITS*density. DIGITS is typically something like 15,30, or 60
and density is a handful, a number that one can count on fingers, so somewhere near one or two hundred terms on the LHS
typically get evaluated.


***************************************************************************************************/

//this should be (is) called just once, not each time test is called
//We could also speed this up by restricting n in c(n) to prime powers n,
//but in practice, I use this for small (around 100) num_coeffs, so it's not a big deal
//to overdo it a bit.
template <class ttype>
int L_function <ttype>::
dirichlet_coeffs_log_diff(int num_coeffs, Complex *c)
{

  Complex b[num_coeffs+1];
  int j, n, d1, ind;
  Complex total, total2, temp;

  if(my_verbose>1) cout << "    Computing " << num_coeffs << " Dirichlet coefficients of the logarithmic derivative" << endl;

  if (what_type_L != 1 && what_type_L != -1
    && num_coeffs > number_of_dirichlet_coefficients)
  {
      cout << "Don't have enough Dirichlet coefficients." << endl;
      return 1;
  }
  b[1] = 1;


  for (n=2;n<=num_coeffs;n++)
  {
    total = 0.;
    total2 = 0.;
    for (j=1;j<=n/2;j++)
      if (n % j == 0)
      {
        d1 = n/j;
        if (what_type_L == -1)
          temp = b[j];
        else if (what_type_L == 1)
        {
          ind = d1 % period;
          if (ind == 0)
            ind = period;
          temp = dirichlet_coefficient[ind]*b[j];
        }
        else
          temp = dirichlet_coefficient[d1]*b[j];
        total -= temp;
        total2 += temp*LOG(d1);
      }
    b[n] = total;
    c[n] = total2;
    if(my_verbose>4) cout << "                c[" << n << "] = " << c[n] << endl;
  }


  return 0;
}

/************************************************************************************************/

template <class ttype>
int L_function <ttype>::
test_explicit_formula(Double alpha, Double x_0, Double *zero_table, int number_zeros, Complex *c, int num_coeffs)
{

  if(my_verbose>2) cout << "Entering test_explicit_formula" << endl;
  Double t, t_begin, t_end, t_step, u;
  Double D;
  Double total;
  Double term1, term2, term3;
  int p, n, x, j;
  Double temp;
  Double LHS, RHS;
  //Complex *c;
  //int num_coeffs;
  int flag;

  //num_coeffs = 150; //XXXXXXXXXX should depend on test required
  //c = new Complex[num_coeffs+1]; //XXXXXXX move to L.h
  //dirichlet_coeffs_log_diff(num_coeffs, c);

  //compute the possible contribution from poles

  term1 = 0.;
  for (j=1;j<=number_of_poles;j++)
    term1 += real(xxx_phi(alpha, x_0, (pole[j]-0.5)/I));

  // compute the contribution from the Gamma factors (integral of the log diff)

  //t_step = .25*Pi/sqrt(2.3*DIGITS*alpha); //bogus formula
  t_step = .05;

  D = ceil(sqrt(DIGITS*2.3/alpha)/t_step) * t_step;
  //for our choice of phi, this gives DIGITS precision
  t_begin = x_0 - D;
  t_end = x_0 + D;
  total = 0.;

  for (t=t_begin;t<=t_end;t=t+t_step)
  {
    temp = 0.;
    for (j=1;j<=this->a;j++)
    {
      temp +=  2*real(log_GAMMA(gamma[j]/2 + I*t*gamma[j]+lambda[j], 1)*gamma[j]); //'1' tells log_GAMMA to compute the logarithmic derivative
      //temp +=  log_GAMMA(gamma[j]/2 - I*t*gamma[j]+conj(lambda[j]), 1)*gamma[j];
    }
    total = total + real(xxx_phi(alpha, x_0, t)) * temp; //xxx_phi in this line is real, but the value is returned as a Complex,
                                                     //so we take it's real part since total is a Double
    //cout << t << " term2 " << total*t_step/(2*Pi) << endl;
  }

  term2 = t_step*total + 2*log(Q)*sqrt(Pi/alpha);
  term2 = 1/(2*Pi) * term2;

  //compute the contribution from the Dirichlet coefficients

  x = num_coeffs;
  //extend_prime_table(x);

  j = 0;
  p = get_prime(j);
  term3 = 0.;

  while (p <= x)
  {
    n = p;
    while (n <= x)
    {
      temp = 2*real(c[n]*xxx_phi_hat(alpha, x_0, LOG(n)/(2*Pi)));// + conj(c[n])*xxx_phi_hat(alpha, x_0, -LOG(n)/(2*Pi));
      term3 += two_inverse_sqrt(n)*temp;
      //cout << n << " RHS prime power contribution: " << temp << endl;
      n = n * p;
    }
    j = j + 1;
    p = get_prime(j);
  }
  term3 = 1/(4*Pi) * term3;

  /*** COMPUTE RHS ***/

  RHS = term1 + term2 - term3;

  /*** COMPUTE LHS ***/

  LHS = 0.;
  //we will want to truncate this automatically
  for (j=0;j<=number_zeros-1;j++)
  {

    u=zero_table[j]-x_0;
    u=u*u*alpha;
    if(u<2.3*DIGITS+2){
        LHS += exp(-u);
        //cout << "LHS, u: " << u << " , contribution: " << exp(-u) << endl;
    }
  }

  /*** Display Results ***/

  if(my_verbose > 2)
  {
    cout << endl << endl;
    cout << "*** Testing Explicit Formula for L ***" << endl;
    cout << "alpha = " << alpha << endl;
    cout << "x_0 = " << x_0 << endl;
    cout << "D = " << D << endl;
    cout << "TERM 1:  " << term1 << endl;
    cout << "TERM 2:  " << term2 << endl;
    cout << "TERM 3:  " << term3 << endl;
    cout << "RHS:  " << RHS << endl;
    cout << "LHS:  " << LHS << endl;
    cout << "LHS - RHS:  " << LHS-RHS << endl;
    cout << "CUTOFF:  " << pow(10.0, -DIGITS/3) << endl;
  }

  Double DIFF=abs(LHS-RHS);
  Double RELATIVE_DIFF=DIFF/(abs(x_0)+1); // denominator to take into account
  // the fact that our test function localizes at x_0, i.e is a function of x_0-x, so
  // precision is lost due to this subtraction.

  if(RELATIVE_DIFF>xxx_max_DIFF) xxx_max_DIFF=RELATIVE_DIFF;

  if(my_verbose!=0){
      cout << "alpha = " << alpha << ", x_0 = " << x_0 << ", ";
      //cout << " x_0=" << x_0 << ",";
      cout << "DIFF = " << DIFF << ", RELATIVE_DIFF = " << RELATIVE_DIFF << ", ";
      cout << "max_relative_DIFF = " << xxx_max_DIFF << ", ";
  }


  if(xxx_max_DIFF<tolerance) DIGITS_xxx=DIGITS;
  else DIGITS_xxx=Int(-log(xxx_max_DIFF)/2.3+1); //adjust output precision for the zeros.
  if(DIGITS_xxx<2) DIGITS_xxx=2; //to prevent cout errors, never set output precision less than 2 digits.

  if (DIFF < 1e-2) //if results agree to at least two places after the decimal
  {
    flag = 0;
    if(my_verbose!=0) cout << "PASS." << endl;
  }
  else
  {
    flag = 1;
    if(my_verbose!=0) cout << "FAIL!" << endl;
  }

  return flag;
}

template <class ttype>
Double L_function <ttype>::
rhs_explicit_formula(Double alpha, Double x_0, Complex *c, int num_coeffs)
{

  if(my_verbose>2) cout << "Entering rhs_explicit_formula" << endl;
  Double t, t_begin, t_end, t_step;
  Double D;
  Double total;
  Double term1, term2, term3;
  int p, n, x, j;
  Double temp;
  Double RHS;
  //Complex *c;
  //int num_coeffs;

  //num_coeffs = 150; //XXXXXXXXXX should depend on test required
  //c = new Complex[num_coeffs+1]; //XXXXXXX move to L.h
  //dirichlet_coeffs_log_diff(num_coeffs, c);

  //compute the possible contribution from poles

  term1 = 0.;
  for (j=1;j<=number_of_poles;j++)
    term1 += real(xxx_phi(alpha, x_0, (pole[j]-0.5)/I));

  // compute the contribution from the Gamma factors (integral of the log diff)

  //t_step = .25*Pi/sqrt(2.3*DIGITS*alpha); //bogus formula
  t_step = .05;

  D = ceil(sqrt(DIGITS*2.3/alpha)/t_step) * t_step;
  //for our choice of phi, this gives DIGITS precision
  t_begin = x_0 - D;
  t_end = x_0 + D;
  total = 0.;

  for (t=t_begin;t<=t_end;t=t+t_step)
  {
    temp = 0.;
    for (j=1;j<=this->a;j++)
    {
      temp +=  2*real(log_GAMMA(gamma[j]/2 + I*t*gamma[j]+lambda[j], 1)*gamma[j]); //'1' tells log_GAMMA to compute the logarithmic derivative
      //temp +=  log_GAMMA(gamma[j]/2 - I*t*gamma[j]+conj(lambda[j]), 1)*gamma[j];
    }
    total = total + real(xxx_phi(alpha, x_0, t)) * temp; //xxx_phi in this line is real, but the value is returned as a Complex,
                                                     //so we take it's real part since total is a Double
    //cout << t << " term2 " << total*t_step/(2*Pi) << endl;
  }

  term2 = t_step*total + 2*log(Q)*sqrt(Pi/alpha);
  term2 = 1/(2*Pi) * term2;

  //compute the contribution from the Dirichlet coefficients

  x = num_coeffs;
  //extend_prime_table(x);

  j = 0;
  p = get_prime(j);
  term3 = 0.;

  while (p <= x)
  {
    //n = p;
    n = 1;
    do
    {
      n *= p;
      temp = 2*real(c[n]*xxx_phi_hat(alpha, x_0, LOG(n)/(2*Pi)));// + conj(c[n])*xxx_phi_hat(alpha, x_0, -LOG(n)/(2*Pi));
      term3 += two_inverse_sqrt(n)*temp;
    }while(double(n)*p <= x);
    j = j + 1;
    p = get_prime(j);
  }
  term3 = 1/(4*Pi) * term3;

  /*** COMPUTE RHS ***/

  RHS = term1 + term2 - term3;


  /*** Display Results ***/

  if(my_verbose > 2)
  {
    cout << endl << endl;
    cout << "*** Testing Explicit Formula for L ***" << endl;
    cout << "alpha = " << alpha << endl;
    cout << "x_0 = " << x_0 << endl;
    cout << "D = " << D << endl;
    cout << "TERM 1:  " << term1 << endl;
    cout << "TERM 2:  " << term2 << endl;
    cout << "TERM 3:  " << term3 << endl;
    cout << "RHS:  " << RHS << endl;
  }

  return RHS;
}

template <class ttype>
int L_function <ttype>::
plot_explicit_formula(Double alpha, Double x, Double x2, Double step_size){

    //phi_hat is, in size, exp(-pi^2/alpha (log(n)/(2pi))^2)

    int number_of_log_diff_coeff;

    double N_as_double = lcalc_to_double(exp(sqrt(2.3*DIGITS*4*alpha))); //as double because we might exceed INT_MAX
    if (what_type_L != 1 && what_type_L != -1 && N_as_double> number_of_dirichlet_coefficients){
        cout << "Don't have enough (" << N_as_double << ") Dirichlet coefficients. " << endl;
        cout << "Will use the maximum, "<< number_of_dirichlet_coefficients <<" , available." << endl;
        number_of_log_diff_coeff = number_of_dirichlet_coefficients;
        Double tmp= log(number_of_log_diff_coeff)/(2*Pi);
        cout << "These can only give the rhs of the explicit formula to within: " << exp(-Pi*Pi/alpha*tmp*tmp) << endl;
    }
    else if ((what_type_L != 1 || what_type_L != -1)&&number_of_log_diff_coeff>1000000){
        cout << "Will use p^k < 100000" << endl;
        number_of_log_diff_coeff=100000; //for zeta or Dirichlet L-functions I've set the max number of terms at 100000
        Double tmp= log(number_of_log_diff_coeff)/(2*Pi);
        cout << "These can only give compute the rhs of the explicit formula to within: " << exp(-Pi*Pi/alpha*tmp*tmp) << endl;

    }
    else number_of_log_diff_coeff=Int(exp(sqrt(2.3*DIGITS*4*alpha)));

    if(my_verbose>2){
        cout << "plot_explicit_formula called with: alpha = "<< alpha << ", " << x << " <= x0 <= " << x2 << endl;
        cout << "Will use: " << number_of_log_diff_coeff << " terms of the logarithmic derivative" << endl;
    }

    Complex *xxx_log_diff_coeffs;
    xxx_log_diff_coeffs = new Complex[number_of_log_diff_coeff+1];

    dirichlet_coeffs_log_diff(number_of_log_diff_coeff, xxx_log_diff_coeffs);

    Double t=x;
    do{
        cout << t;
        cout << " " << rhs_explicit_formula(alpha,t,xxx_log_diff_coeffs,number_of_log_diff_coeff) << endl;
        t+=step_size;
    }while(t<=x2);
    delete [] xxx_log_diff_coeffs;
    return 0;
}
#endif
